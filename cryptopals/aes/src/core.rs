use ndarray::{Array2, arr2, ArrayViewMut2, ArrayView2, s};

fn get_s_box(b: &u8, invert: bool) -> u8 {
    let s_box: Array2<u8> = arr2(&[
        [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76],
        [0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0],
        [0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15], 
        [0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75], 
        [0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84], 
        [0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf], 
        [0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8], 
        [0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2], 
        [0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73], 
        [0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb], 
        [0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79], 
        [0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08], 
        [0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a], 
        [0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e], 
        [0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf], 
        [0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16],
    ]);
    let inv_s_box: Array2<u8> = arr2(&[
        [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb], 
        [0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb], 
        [0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e], 
        [0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25], 
        [0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92], 
        [0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84], 
        [0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06], 
        [0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b], 
        [0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73], 
        [0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e], 
        [0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b], 
        [0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4], 
        [0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f], 
        [0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef], 
        [0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61], 
        [0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d],
    ]);
    let row = ((b & 0xF0) >> 4) as usize;
    let col = (b & 0x0F) as usize;
    if invert {   
        *(inv_s_box.get((row, col)).unwrap())          
    } else {
        *(s_box.get((row, col)).unwrap())
    }
}

fn add_round_key<'a>(mut state: ArrayViewMut2<'a, u8>, w: ArrayView2<u8>) {
    state ^= &w;
}

fn sub_bytes<'a>(mut state: ArrayViewMut2<'a, u8>)  {
    state.mapv_inplace(|b| {
        get_s_box(&b, false)
    });
}

fn inv_sub_bytes<'a>(mut state: ArrayViewMut2<'a, u8>)  {
    state.mapv_inplace(|b| {
        get_s_box(&b, true)
    });
}

fn shift_rows<'a>(mut state: ArrayViewMut2<'a, u8>) {
    let mut i = 0;
    for mut row in state.rows_mut() {
        row.as_slice_mut().unwrap().rotate_left(i);
        i += 1;
    }
}

fn inv_shift_rows<'a>(mut state: ArrayViewMut2<'a, u8>) {
    let mut i = 0;
    for mut row in state.rows_mut() {
        row.as_slice_mut().unwrap().rotate_right(i);
        i += 1;
    }
}

fn galois_field_mul(mut a: u8, mut b: u8) -> u8 {
    let mut p: u8 = 0;
    for _ in 0..8 {
        if b & 1 != 0 {
            p ^= a;
        }
        let h = a & 0x80 != 0;
        a <<= 1;
        if h {
            a ^= 0x1b;
        }
        b >>= 1;
    }
    p
}

fn mix_columns<'a>(mut state: ArrayViewMut2<'a, u8>) {
    for mut col in state.columns_mut() {
        let a = galois_field_mul(0x02, col[0])
                ^ galois_field_mul(0x03, col[1]) ^ col[2] ^ col[3];
        let b = col[0] ^ galois_field_mul(0x02, col[1])
                ^ galois_field_mul(0x03, col[2]) ^ col[3];
        let c = col[0] ^ col[1] ^ galois_field_mul(0x02, col[2]) 
                ^ galois_field_mul(0x03, col[3]);
        let d = galois_field_mul(0x03, col[0])
                ^ col[1] ^ col[2] ^ galois_field_mul(0x02, col[3]);
        col[0] = a;
        col[1] = b;
        col[2] = c;
        col[3] = d;
    }
}

fn inv_mix_columns<'a>(mut state: ArrayViewMut2<'a, u8>) {
    for mut col in state.columns_mut() {
        let a = galois_field_mul(0x0e, col[0])
                ^ galois_field_mul(0x0b, col[1]) 
                ^ galois_field_mul(0x0d, col[2]) 
                ^ galois_field_mul(0x09, col[3]);
        let b = galois_field_mul(0x09, col[0])
                ^ galois_field_mul(0x0e, col[1]) 
                ^ galois_field_mul(0x0b, col[2]) 
                ^ galois_field_mul(0x0d, col[3]);
        let c = galois_field_mul(0x0d, col[0])
                ^ galois_field_mul(0x09, col[1]) 
                ^ galois_field_mul(0x0e, col[2]) 
                ^ galois_field_mul(0x0b, col[3]);
        let d = galois_field_mul(0x0b, col[0])
                ^ galois_field_mul(0x0d, col[1]) 
                ^ galois_field_mul(0x09, col[2]) 
                ^ galois_field_mul(0x0e, col[3]);
        col[0] = a;
        col[1] = b;
        col[2] = c;
        col[3] = d;
    }
}

fn rot_word(word: &mut [u8]) {
    word.rotate_left(1);
}

fn sub_word<'a>(word: &mut [u8])  {
    word.iter_mut().for_each(|b| {
        *b = get_s_box(&b, false);
    })
}

pub fn key_expansion(key: &[u8], nk: &u8, nr: &u8) -> Array2<u8> {
    let mut key_schedule: Vec<u8> = Vec::new();
    let rcon0: Vec<u8> = vec![0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    let mut rcon0_iter = rcon0.into_iter();
    key.iter().for_each(|&b| key_schedule.push(b));
    for i in *nk..(4*(*nr+1)) {
        let mut tmp: [u8; 4] = [0; 4];
        tmp.copy_from_slice(&key_schedule[((i-1)*4) as usize..(i*4) as usize]);
        if i % nk == 0 {
            rot_word(&mut tmp);
            sub_word(&mut tmp);
            let rcon: [u8; 4] = [rcon0_iter.next().unwrap(), 0, 0, 0];
            tmp.iter_mut().zip(rcon.into_iter()).for_each(|(a,b)| *a ^= b);
        } else if *nk > 6 && i % *nk == 4 {
            sub_word(&mut tmp);
        } else {
            // do nothing
        }
        let mut prev_key: [u8; 4] = [0; 4];
        prev_key.copy_from_slice(&key_schedule[((i-nk)*4) as usize..((i-nk+1)*4) as usize]);
        let new_key = prev_key.iter().zip(tmp.iter())
                                .map(|(&a, &b)| a ^ b).collect::<Vec<u8>>();
        new_key.iter().for_each(|&b| key_schedule.push(b));
    }
    let row = (*nr as usize + 1) * 4;
    let ks_arr = Array2::from_shape_vec((row,4), key_schedule).unwrap();
    ks_arr
}

fn aes_inout_reorder(v: &[u8]) -> Vec<u8> {
    let mut v_reorder: Vec<u8> = Vec::new();
    for i in 0..v.len()/4 {
        for j in 0..4 as usize {
            v_reorder.insert(4*i+j, v[4*j+i]);
        }
    }
    v_reorder
}

pub fn aes_encrypt(pt: &[u8], w: &Array2<u8>, nr: &u8) -> Vec<u8> {
    let mut state = 
        Array2::from_shape_vec((4,4), aes_inout_reorder(pt)).unwrap();
    add_round_key(state.view_mut(), w.slice(s![0..4 as usize, ..]).t());
    for i in 1..*nr {
        sub_bytes(state.view_mut());
        shift_rows(state.view_mut());
        mix_columns(state.view_mut());
        add_round_key(state.view_mut(), w.slice(s![(4*i) as usize..(4*(i+1)) as usize, ..]).t());
    }
    sub_bytes(state.view_mut());
    shift_rows(state.view_mut());
    add_round_key(state.view_mut(), w.slice(s![(4*nr) as usize..(4*(nr+1)) as usize, ..]).t());
    aes_inout_reorder(&(state.into_raw_vec()))
}

pub fn aes_decrypt(cipher: &[u8], w: &Array2<u8>, nr: &u8) -> Vec<u8> {
    let mut state = 
        Array2::from_shape_vec((4,4), aes_inout_reorder(cipher)).unwrap();
    add_round_key(state.view_mut(), w.slice(s![(4*nr) as usize..(4*(nr+1)) as usize, ..]).t());
    for i in (1..*nr).rev() {
        inv_shift_rows(state.view_mut());
        inv_sub_bytes(state.view_mut());
        add_round_key(state.view_mut(), w.slice(s![(4*i) as usize..(4*(i+1)) as usize, ..]).t());
        inv_mix_columns(state.view_mut());
    }
    inv_shift_rows(state.view_mut());
    inv_sub_bytes(state.view_mut());
    add_round_key(state.view_mut(), w.slice(s![0..4 as usize, ..]).t());
    aes_inout_reorder(&(state.into_raw_vec()))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_round_key() {
        let mut state: Array2<u8> = arr2(&[
            [0x32, 0x88, 0x31, 0xe0],
            [0x43, 0x5a, 0x31, 0x37],
            [0xf6, 0x30, 0x98, 0x07],
            [0xa8, 0x8d, 0xa2, 0x34]
        ]);
        let w: Array2<u8> = arr2(&[
            [0x2b, 0x28, 0xab, 0x09],
            [0x7e, 0xae, 0xf7, 0xcf],
            [0x15, 0xd2, 0x15, 0x4f],
            [0x16, 0xa6, 0x88, 0x3c]
        ]);
        let result: Array2<u8> = arr2(&[
            [0x19, 0xa0, 0x9a, 0xe9],
            [0x3d, 0xf4, 0xc6, 0xf8],
            [0xe3, 0xe2, 0x8d, 0x48],
            [0xbe, 0x2b, 0x2a, 0x08]
        ]);
        add_round_key(state.view_mut(), w.view());
        assert_eq!(result, state);
    }

    #[test]
    fn test_get_s_box() {
        let x = get_s_box(&0x02, false);
        assert_eq!(0x77, x);    
    }

    #[test]
    fn test_sub_bytes() {
        let mut state: Array2<u8> = arr2(&[
            [0x19, 0xa0, 0x9a, 0xe9],
            [0x3d, 0xf4, 0xc6, 0xf8],
            [0xe3, 0xe2, 0x8d, 0x48],
            [0xbe, 0x2b, 0x2a, 0x08]
        ]);
        let result: Array2<u8> = arr2(&[
            [0xd4, 0xe0, 0xb8, 0x1e],
            [0x27, 0xbf, 0xb4, 0x41],
            [0x11, 0x98, 0x5d, 0x52],
            [0xae, 0xf1, 0xe5, 0x30]
        ]);
        sub_bytes(state.view_mut());
        assert_eq!(result, state);
    }

    #[test]
    fn test_shift_rows() {
        let mut state: Array2<u8> = arr2(&[
            [0xd4, 0xe0, 0xb8, 0x1e],
            [0x27, 0xbf, 0xb4, 0x41],
            [0x11, 0x98, 0x5d, 0x52],
            [0xae, 0xf1, 0xe5, 0x30]
        ]);
        let result: Array2<u8> = arr2(&[
            [0xd4, 0xe0, 0xb8, 0x1e],
            [0xbf, 0xb4, 0x41, 0x27],
            [0x5d, 0x52, 0x11, 0x98],
            [0x30, 0xae, 0xf1, 0xe5]
        ]);
        shift_rows(state.view_mut());
        assert_eq!(result, state);
    }

    #[test]
    fn test_mix_columns() {
        let mut state: Array2<u8> = arr2(&[
            [0xd4, 0xe0, 0xb8, 0x1e],
            [0xbf, 0xb4, 0x41, 0x27],
            [0x5d, 0x52, 0x11, 0x98],
            [0x30, 0xae, 0xf1, 0xe5]
        ]);
        let result: Array2<u8> = arr2(&[
            [0x04, 0xe0, 0x48, 0x28],
            [0x66, 0xcb, 0xf8, 0x06],
            [0x81, 0x19, 0xd3, 0x26],
            [0xe5, 0x9a, 0x7a, 0x4c]
        ]);
        mix_columns(state.view_mut());
        assert_eq!(result, state);
    }

    #[test]
    fn test_rot_word() {
        let mut word: [u8; 4] = [0x09, 0xcf, 0x4f, 0x3c];
        let result: [u8; 4] = [0xcf, 0x4f, 0x3c, 0x09];
        rot_word(&mut word);
        assert_eq!(result, word);
    }

    #[test]
    fn test_sub_word() {
        let mut word: [u8; 4] = [0xcf, 0x4f, 0x3c, 0x09];
        let result: [u8; 4] = [0x8a, 0x84, 0xeb, 0x01];
        sub_word(&mut word);
        assert_eq!(result, word);
    }

    #[test]
    fn test_key_expansion() {
        let key_schedule: Array2<u8> = arr2(&[
            [0x2b, 0x7e, 0x15, 0x16],
            [0x28, 0xae, 0xd2, 0xa6],
            [0xab, 0xf7, 0x15, 0x88],
            [0x09, 0xcf, 0x4f, 0x3c],
            [0xa0, 0xfa, 0xfe, 0x17],
            [0x88, 0x54, 0x2c, 0xb1],
            [0x23, 0xa3, 0x39, 0x39],
            [0x2a, 0x6c, 0x76, 0x05],
            [0xf2, 0xc2, 0x95, 0xf2],
            [0x7a, 0x96, 0xb9, 0x43],
            [0x59, 0x35, 0x80, 0x7a],
            [0x73, 0x59, 0xf6, 0x7f],
            [0x3d, 0x80, 0x47, 0x7d],
            [0x47, 0x16, 0xfe, 0x3e],
            [0x1e, 0x23, 0x7e, 0x44],
            [0x6d, 0x7a, 0x88, 0x3b],
            [0xef, 0x44, 0xa5, 0x41],
            [0xa8, 0x52, 0x5b, 0x7f],
            [0xb6, 0x71, 0x25, 0x3b],
            [0xdb, 0x0b, 0xad, 0x00],
            [0xd4, 0xd1, 0xc6, 0xf8],
            [0x7c, 0x83, 0x9d, 0x87],
            [0xca, 0xf2, 0xb8, 0xbc],
            [0x11, 0xf9, 0x15, 0xbc],
            [0x6d, 0x88, 0xa3, 0x7a],
            [0x11, 0x0b, 0x3e, 0xfd],
            [0xdb, 0xf9, 0x86, 0x41],
            [0xca, 0x00, 0x93, 0xfd],
            [0x4e, 0x54, 0xf7, 0x0e],
            [0x5f, 0x5f, 0xc9, 0xf3],
            [0x84, 0xa6, 0x4f, 0xb2],
            [0x4e, 0xa6, 0xdc, 0x4f],
            [0xea, 0xd2, 0x73, 0x21],
            [0xb5, 0x8d, 0xba, 0xd2],
            [0x31, 0x2b, 0xf5, 0x60],
            [0x7f, 0x8d, 0x29, 0x2f],
            [0xac, 0x77, 0x66, 0xf3],
            [0x19, 0xfa, 0xdc, 0x21],
            [0x28, 0xd1, 0x29, 0x41],
            [0x57, 0x5c, 0x00, 0x6e],
            [0xd0, 0x14, 0xf9, 0xa8],
            [0xc9, 0xee, 0x25, 0x89],
            [0xe1, 0x3f, 0x0c, 0xc8],
            [0xb6, 0x63, 0x0c, 0xa6],
        ]);
        let key: Vec<u8> = vec![
            0x2b, 0x7e, 0x15, 0x16,
            0x28, 0xae, 0xd2, 0xa6,
            0xab, 0xf7, 0x15, 0x88,
            0x09, 0xcf, 0x4f, 0x3c,
        ];
        assert_eq!(key_schedule, key_expansion(&key, &4, &10));
    }

    #[test]
    fn test_aes() {
        use hex;
        struct AESTEST {
            text: Vec<u8>,
            key: Vec<u8>,
            cipher: Vec<u8>,
            nk: u8,
            nr: u8,
        }
    
        let data = [
            AESTEST {
                text: hex::decode("6bc1bee22e409f96e93d7e117393172a").unwrap(),
                key: hex::decode("2b7e151628aed2a6abf7158809cf4f3c").unwrap(),
                cipher: hex::decode("3ad77bb40d7a3660a89ecaf32466ef97").unwrap(),
                nk: 4u8,
                nr: 10u8,
            },
            AESTEST {
                text: hex::decode("6bc1bee22e409f96e93d7e117393172a").unwrap(),
                key: hex::decode("8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b").unwrap(),
                cipher: hex::decode("bd334f1d6e45f25ff712a214571fa5cc").unwrap(),
                nk: 6u8,
                nr: 12u8,
            },
            AESTEST {
                text: hex::decode("6bc1bee22e409f96e93d7e117393172a").unwrap(),
                key: hex::decode("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4").unwrap(),
                cipher: hex::decode("f3eed1bdb5d2a03c064b5a7e3db181f8").unwrap(),
                nk: 8u8,
                nr: 14u8,
            },
        ];

        for item in data {
            assert_eq!(item.cipher, 
                aes_encrypt(&item.text,
                            &key_expansion(&item.key, &item.nk, &item.nr),
                            &item.nr));
            assert_eq!(item.text, 
                aes_decrypt(&item.cipher,
                            &key_expansion(&item.key, &item.nk, &item.nr),
                            &item.nr));
        }
    }

    #[test]
    fn test_ndarray_strides() {
        let a = Array2::from_shape_vec((2, 2), 
                vec![1., 2., 3., 4.]);
        assert!(a.is_ok());
        
        let pt: Vec<u8> = vec![
            0x32, 0x43, 0xf6, 0xa8,
            0x88, 0x5a, 0x30, 0x8d,
            0x31, 0x31, 0x98, 0xa2,
            0xe0, 0x37, 0x07, 0x34,
            0x32, 0x43, 0xf6, 0xa8,
            0x88, 0x5a, 0x30, 0x8d,
            0x31, 0x31, 0x98, 0xa2,
            0xe0, 0x37, 0x07, 0x34,
        ];
        let v = ArrayView2::from_shape((8, 4), &pt).unwrap();
        // println!("{:02x?}", v);
        // println!("{:02x?}", v.slice(s![0..4 as usize, ..]).t());
        // println!("row = {}, col = {}", v.nrows(), v.ncols());
    
        assert!(
            v.slice(s![0..4 as usize, ..]).t() == arr2(&[[0x32, 0x88, 0x31, 0xe0],
                        [0x43, 0x5a, 0x31, 0x37],
                        [0xf6, 0x30, 0x98, 0x07],
                        [0xa8, 0x8d, 0xa2, 0x34],])
        );       
    }
}